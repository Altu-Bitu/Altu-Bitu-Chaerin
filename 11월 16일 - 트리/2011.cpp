//
// Created by 김채린 on 2021/11/23.
//

#include <iostream>
#include <vector>

using namespace std;
const int MOD = 1e6;

// 암호의 해석이 몇 가지가 나올 수 있는지 구하는 함수 (n : 암호의 길이, s : 암호)
int cntPassword(int n, string s) {

    // 암호의 i 인덱스까지 가능한 해석의 수를 저장할 벡터
    vector<int> dp(n + 1, 0);

    // 암호의 처음 시작이 0이면 해석 불가
    if (s[0] == '0')
        // 암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 반환ㄴ
        return 0;

    // s[0]의 암호 해석 경우의 수 1로 초기화
    dp[0] = dp[1] = 1;

    // 점화식 적용 부분
    for (int i = 2; i <= n; i++) {
        // 현재 수가 '0'인데 앞의 수가 '1'이나 '2'가 아닌 경우 -> 암호 해석할 수 없음
        if (s[i - 1] == '0' && (s[i - 2] < '1' || s[i - 2] > '2'))
            // 암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 반환
            return 0;
        // 하나의 수를 하나의 알파벳으로 고려
        if (s[i - 1] != '0')
            // 현재 수만 고려하므로 바로 직전 인덱스까지 가능한 해석의 수를 그대로 더해줌
            dp[i] += dp[i - 1];
        // 두 개의 수를 하나의 알파벳으로 고려할 때, 26이하의 수인지 확인
        if (s[i - 2] == '1' || (s[i - 1] <= '6' && s[i - 2] == '2'))
            // 두 개의 수를 고려하므로 전전 인덱스까지 가능한 해석의 수를 더해줌
            dp[i] += dp[i - 2];
        // ~로 나눈 나머지를 구하는 문제에서는 마지막 출력때만 나누어주는 것이 아니라
        // 매번 나누어주어야 안전!!
        dp[i] %= MOD;
    }

    // 암호 전체(= 암호의 n 인덱스까지)에서 가능한 해석의 수를 반환
    return dp[n];
}

/**
 * dp[i] = i인덱스까지 암호 해석할 수 있는 경우의 수 저장
 * => dp[i] = dp[i-1] + dp[i-2] (단, dp[i-1]과 dp[i-2]에서 이어서 암호 만들 수 있는 경우만)
 *
 * 1. '0' 혼자는 암호 해석 불가
 * 2. 처음 시작이 '0'인 경우 주의
 * 3. 현재 수가 '0'인데 앞의 수가 '1'이나 '2'가 아닌 경우 -> 암호 해석할 수 없음
 * 4. 두 개의 수를 하나의 알파벳으로 고려할 때, 26이하의 수인지 잘 확인해야 함
 *
 * 본 풀이는 dp 배열 인덱스를 편하게 관리하기 위해 1번 인덱스부터 시작
 */

int main() {

    // 암호를 저장할 변수 s
    string s;

    // 입력
    cin >> s;

    // 연산 & 출력
    cout << cntPassword(s.length(), s) << '\n';

    // 종료
    return 0;
}